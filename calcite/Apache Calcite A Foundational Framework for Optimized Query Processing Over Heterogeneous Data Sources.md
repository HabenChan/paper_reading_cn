# Apache Calcite: A Foundational Framework for Optimized Query Processing Over Heterogeneous Data Sources

## 摘要

Apache Calcite 是一个基础软件框架，为许多流行的开源数据处理系统（例如 Apache Hive、Apache Storm、Apache Flink、Druid 和 MapD）提供查询处理、优化和查询语言支持。 Calcite 的架构由一个模块化且可扩展的查询优化器（具有数百个内置优化规则）、一个能够处理多种查询语言的查询处理器、一个为可扩展性设计的适配器架构以及对异构数据模型和存储的支持组成。 （关系、半结构化、流媒体和地理空间）。这种灵活、可嵌入和可扩展的架构使得 Calcite 成为大数据框架中采用的有吸引力的选择。这是一个活跃的项目，不断引入对新型数据源、查询语言以及查询处理和优化方法的支持。

## 1.简介

继开创性的Sysytem R之后，传统的关系数据库引擎主导了数据处理领域。然而，早在 2005 年，Stonebraker 和 Çetintemel [49] 预测我们会看到一系列专业引擎的兴起，例如column stores，stream processing engines、text search engine等等。他们认为specialized engines可以提供更具成本效益的2性能，他们将结束“one size fits”的局面。如今来看，他们的愿景似乎比以往任何时候都要更加relevant.

事实上,许多开源数据系统已经开始流行起来了，例如Storm和Flink、ES、Apache Spark、Druid等。

随着各个组织将其特定需求放到数据处理系统上，出现了两个首要问题：

此类specialized systems的开发者已经遇到过相关问题，例如查询优化、或者需要支持对应的查询语言，例如SQL和相关拓展（e.g 流式查询）以及受到LINQ启发的语言集成查。以及制定一个统一的框架，让多名工程师独立去开发类似查询优化逻辑和对其语言的支持，这是十分浪费工作量的

使用此类specialized systems的程序员通常必须将其中几个数据处理系统整合到一起。毕竟一个组织可能同时需要用到ES、Apache Spark和Druid。我们需要去构建能够支持跨异构数据源的优化查询的系统。

Apache Calcite就是为了解决这些问题而开发的。它是一个完整的查询处理系统，提供许多数据库管理系统所需的许多通用功能（查询执行、优化和SQL语义），但数据存储和管理除外，这些功能由专门的引擎负责。Calcite很快就被Hive、Drill、Storm和许多其他数据处理引擎采用，为它们提供了高级查询优化和查询语言。例如，Hive是一个构建在Apache之上的流行数据仓库项目Hadpoop。随着 Hive 从批处理根源转向交互式 SQL 查询应答平台，很明显该项目的核心需要一个强大的优化器。因此，Hive 采用Calcite作为其优化器，此后它们的集成不断增长。许多其他项目和产品也纷纷效仿，包括Flink、MapD 等。

此外，Calcite通过向多个系统公开通用接口来实现跨平台优化。为了提高效率，优化器需要进行全局推理，例如，跨不同系统做出有关物化试图选择和决策。

我们相信，以下功能有助于Calcite在开源社区和行业中的广泛采用：

**开源友好**，许多过去十年主要数据处理平台要么是开源或者基于开源。Calcite是一种开源框架，由 Apache 软件基金会支持化（ASF），它提供了协作的手段开发该项目。 另外，该软件是Java写的使其更容易与许多最新的数据处理系统去适配，通常用 Java（或基于 JVM 的 Scala）编写，尤其是 Hadoop 生态系统中的那些。

**多种数据模型**。Calcite支持针对流式传输的优化和查询，也支持传统数据处理范例。Calcite将流作为按时间排序的记录或事件集不像传统方式那样持久保存到磁盘上数据处理系统

**灵活的查询优化器**。该优化的每个组建mizer是可插拔和可扩展的，无论是从规则还是到成本模型。此外，Calcite 还支持多个规则引擎。因此，优化可以分为由不同优化引擎处理的阶段，具体取决于哪个优化引擎最适合该阶段。

**跨系统支持**。Calcite 框架可以跨多个查询处理系统和数据库后端运行和优化查询。

**可靠性**。Calcite是可靠的，因为多年来它被广泛采用已经导致对该平台进行了详尽的测试。Calcite还包含一个广泛的测试套件，用于验证系统的所有组件，包括查询优化器规则以及与后端数据源的集成。

**支持SQL 及其扩展**。很多系统没有提供自己的查询语言，但更喜欢依赖现有的，例如 SQL。 对于这些，Calcite提供了支持ANSI 标准 SQL 以及各种 SQL 方言的端口和扩展，例如，用于表达式查询在流式引擎或嵌套数据。 此外，Calcite 还包含一个符合要求的驱动程序标准 Java API (JDBC)。

其余部分组织如下。 第 2 节讨论Calcite相关的工作。 第 3 节介绍了 Calcite 的架构及其主要内容 成分。 第 4 节描述了Calcite中核心的关系代数。 第 5 节介绍了Calcite的适配器，这是对定义如何读取外部数据源。 反过来，第 6 节描述了Calcite 的优化器及其主要功能，第 7 节介绍处理不同查询处理范例的扩展。第 8 节概述了已经存在的数据处理系统使用Calcite。在第 10 节结束之前，第 9 节讨论了该框架未来可能的扩展。

## 2.相关工作

尽管 Calcite 是目前 Hadoop 生态系统中最广泛采用的大数据分析优化器，但其背后的许多想法并不新颖。例如，查询优化器建立在 Volcano 和Cascades 框架的思想之上，结合了其他广泛使用的优化技术，例如物化视图重写。还有其他系统试图扮演与方解石类似的角色

**Orca** 是一个模块化查询优化器，用于 Greenplum 和 HAWQ 等数据管理产品。 Orca通过实现一个在两者之间交换信息的框架（称为数据交换语言），将优化器与查询执行引擎解耦。 Orca 还提供了用于验证生成的查询计划的正确性和性能的工具。与 Orca 相比，Calcite 可以用作独立的查询执行引擎，联合多个存储和处理后端，包括可插入规划器和优化器。

**Spark SQL**扩展了 Apache Spark 以支持 SQL 查询执行，它还可以像 Calcite 一样对多个数据源执行查询。然而，尽管 Spark SQL 中的Catalyst 优化器也尝试最小化查询执行成本，但它缺乏Calcite 使用的动态编程方法，并且存在陷入局部最小值的风险。

**Algebricks** 是一种查询编译器架构，为大数据查询处理提供与数据模型无关的代数层和编译器框架。高级语言被编译为 Algebricks 逻辑代数。然后，Algebricks 生成针对 Hyracks 并行处理后端的优化作业。虽然Calcite 与Algebricks 共享模块化方法，但 Calcite 还支持基于成本的优化。在 Calcite的当前版本中，查询优化器架构使用基于 Volcano的基于动态编程的规划，以及Orca中的多阶段优化扩展。虽然原则上Algebricks 可以支持多个处理后端（例如Apache Tez、Spark），但 Calcite多年来一直为各种后端提供经过充分测试的支持。

Garlic是一个异构数据管理系统，它在统一的对象模型下表示来自多个系统的数据。然而，Garlic 不支持跨不同系统的查询优化，而是依赖每个系统来优化自己的查询。

**FORWARD** 是一个联合查询处理器，它实现了名为 SQL++ 的SQL 超集。 SQL++具有集成JSON和关系数据模型的半结构化数据模型，而Calcite通过在查询规划期间在关系数据模型中表示半结构化数据模型来支持半结构化数据模型。

另一个联合数据存储和处理系统是 **BigDAWG** ，它抽象了广泛的数据模型，包括关系、时间序列和流式传输。抽象单位为BigDAWG 被称为I**sland of information**。每个I**sland of information**都有一种查询语言、数据模型，并连接到一个或多个存储系统。在单个I**sland of information**的边界内支持跨存储系统查询。相反，Caclite提供了统一的关系抽象，允许使用不同的数据模型跨后端进行查询。

![image](https://github.com/caicancai/paper_reading_CN/assets/77189278/fc3b6654-2143-4e0e-a04c-36379ae21ff9)


## 3.架构

Calcite 包含构成典型数据库管理系统的许多部分。然而，它省略了一些关键组件，例如数据存储、处理数据的算法以及用于存储元数据的存储库。这些省略是故意的：它使 Calcite成为在具有一个或多个数据存储位置并使用多个数据处理引擎的应用程序之间进行调解的绝佳选择。它也是构建定制数据处理系统的坚实基础。

图1概述了Calcite架构的主要组件。

Calcite 的优化器使用关系运算符树作为其内部表示。优化引擎主要由三个组件组成：规则、元数据提供程序和规划器引擎。我们将在第 6 节中更详细地讨论这些组件。在图中，虚线表示与框架可能的外部交互。与方解石相互作用的方式有多种。

首先，Calcite 包含一个查询解析器和校验器，可以将 SQL 查询转换为关系运算符树。由于 Calcite不包含存储层，因此它提供了一种通过适配器在外部存储引擎中定义表模式和视图的机制（在第 5 节中描述），因此它可以在这些引擎之上使用。

其次，虽然 Calcite 为需要此类数据库语言支持的系统提供了优化的 SQL支持，但它也为已经拥有自己的语言解析和解释的系统提供了优化支持：

某些系统支持SQL 查询，但没有或有有限的查询优化。例如，Hive 和Spark最初都提供了对 SQL 语言的支持，但它们不包含优化器。对于这种情况，一旦查询得到优化，Calcite 就可以将关系表达式转换回SQL。此功能允许 Calcite 作为独立系统运行在任何具有 SQL 接口但没有优化器的数据管理系统之上。Calcite 架构不仅是为了优化SQL 查询而定制的。数据处理系统选择将自己的解析器用于自己的查询语言是很常见的。Calcite也可以帮助优化这些查询。

事实上，Calcite 还允许通过直接实例化关系运算符来轻松构建运算符树。可以使用内置的关系表达式生成器界面。

例如，假设我们想要使用表达式生成器来表达以下Apache Pig脚本：

```sql
emp = LOAD 'employee_data ' AS ( deptno , sal );
emp_by_dept = GROUP emp by ( deptno );
emp_agg = FOREACH emp_by_dept GENERATE GROUP as deptno ,
COUNT ( emp . sal ) AS c , SUM ( emp . sal ) as s ;
dump emp_agg ;
```

等效表达式如下所示：

```sql
final RelNode node = builder
. scan (" employee_data ")
. aggregate ( builder . groupKey (" deptno ") ,
builder . count (false , "c") ,
builder . sum (false , "s", builder . field ("sal" )))
. build ();
```

## 4. 查询代数

**Operator**。关系代数是方解石的核心。除了表达最常见的数据操作操作的运算符（例如filter、project、join等）之外，Calcite 还包括满足不同目的的其他运算符，例如能够简洁地表示复杂的操作，或者更多地识别优化机会有效率的。

例如，OLAP、决策和流应用程序通常使用窗口定义来表达复杂的分析函数，例如一段时间内数量或数字或行的移动平均值。因此，Calcite 引入了一个窗口运算符，它封装了窗口定义，即上限和下限、分区等，以及在每个窗口上执行的聚合函数。特质。 Calcite 不使用不同的实体来表示逻辑和物理运算符。相反，它使用特征描述与操作员相关的物理属性。这些特征有助于优化器评估不同替代计划的成本。更改特征值不会更改正在计算的逻辑表达式，即给定运算符生成的行仍然相同。

![image](https://github.com/caicancai/paper_reading_CN/assets/77189278/7f3a131d-db67-4460-b5c0-af251e976e34)


在优化过程中，Calcite 尝试在关系表达式上强制执行某些特征，例如某些列的排序顺序。关系运算符可以实现一个转换器接口，该接口指示如何将表达式的特征从一个值转换为另一个值。

Calcite包括描述关系表达式生成的数据的物理属性的常见特征，例如排序、分组和分区。与 SCOPE 优化器 类似， Calcite 优化器可以推理这些属性并利用它们来找到避免不必要操作的计划。例如，如果排序运算符的输入已经正确排序（可能是因为这与后端系统中的行使用的顺序相同），则可以删除排序操作。

除了这些属性之外，Caclite的主要特征之一是调用约定特征。本质上，特征代表了将执行表达式的数据处理系统。将调用约定作为一个特征使得 Calcite 能够实现其透明地优化查询的目标，这

些查询的执行可能跨越不同的引擎，即约定将被视为任何其他物理属性。

例如，考虑将 MySQL 中保存的 Products 表连接到Splunk 中保存的Orders 表。最初，订单扫描按照 splunk 约定进行，产品扫描按照 jdbc‑mysql 约定进行。这些表必须在各自的引擎内进行扫描。该连接符合逻辑约定，这意味着尚未选择任何实现。此外，图 2 中的 SQL 查询包含一个过

滤器（where子句），该过滤器通过特定于适配器的规则推送到 splunk 中。一种可能的实现是使用 Apache Spark 作为外部引擎：连接转换为 Spark 约定，其输入是从 jdbc‑mysql 和 splunk 到 Spark 约定的转换器。但有一个更有效的实现：利用Splunk 可以通过 ODBC 对 MySQL 执行查找的事实，规划器规则通过 splunk‑to‑spark 转换器推送联接，并且联接现在采用 splunk 约定，在 Splunk 引擎内运行。

## 5. 适配器

适配器是一种架构模式，定义了 Calcite 如何合并不同的数据源以进行一般访问。图 3 描述了它的组件。本质上，适配器由模型、模式和模式工厂组成。该模型是所访问的数据源的物理属性的规范。架构是模型中数据（格式和布局）的定义。

![image](https://github.com/caicancai/paper_reading_CN/assets/77189278/805ad56f-0a5f-4be2-a472-ae79b81e71df)


使用适配器中定义的表来在执行查询时读取数据。适配器可以定义添加到规划器的一组规则。例如，它通常包括将各种类型的逻辑关系表达式转换为适配器约定的相应关系表达式的规则。模式工厂组件从模型获取元数据信息并生成模式。

正如第 4 节中所讨论的，方解石使用称为调用约定的物理特征来识别与特定数据库后端相对应的关系运算符。这些物理运算符实现每个适配器中基础表的访问路径。

当解析查询并将其转换为关系代数表达式时，将为每个表创建一个运算符，表示对该表上数据的扫描。它是适配器必须实现的最小接口。如果适配器实现表扫描运算符，则 Calcite 优化器就能够使用客户端运算符（例如排序、过滤和联接）对这些表执行任意 SQL 查询。

该表扫描运算符包含适配器向适配器的后端数据库发出扫描所需的必要信息。为了扩展适配器提供的功能，Calcite 定义了可枚举调用约定。具有可枚举调用约定的关系运算符只需通过迭代器接口对元组进行操作。这种调用约定允许Calcite 实现每个适配器后端可能不可用的运算符。例如， EnumerableJoin运算符通过从其子节点收集行并连接所需的属性来实现连接。

对于只涉及表中一小部分数据的查询，Calcite 枚举所有元组的效率很低。幸运的是，可以使用相同的基于规则的优化器来实现特定于适配器的优化规则。例如，假设查询涉及对表进行过滤和排序。可以在后端执行过滤的适配器可以实现与LogicalFilter匹配的规则并将其转换为适配器的调用约定。此规则将LogicalFilter转换为另一个Filter实例。这个新的Filter节点的相关成本较低。

这使得 Calcite 能够优化跨适配器的查询。适配器的使用是一种强大的抽象，它不仅可以优化特定后端的查询，还可以跨多个后端优化查询。 Calcite 能够通过将所有可能的逻辑下推到每个后端来适配跨多个后端的表的查询，然后对结果数据执行连接和聚合。实现适配器可以像提供表扫描运算符一样简单，也可以涉及许多高级优化的设计。关系代数中表示的任何表达式都可以下推到具有优化器规则的适配器。

## 6. 查询处理和优化

Calcite 通过将规划器规则重复应用于关系表达式来优化查询。成本模型指导

该过程，规划器引擎尝试生成与原始语义相同但成本较低的替代表达式。

优化器中的每个组件都是可扩展的。 用户可以添加关系运算符、规则、成本模型和统计。

**Planner rules**。Calcite 包含一组用于转换表达式树的规划器规则。特别是，规则匹配树中的给定模式并执行保留该表达式语义的转换。Calcite包含数百个优化规则。然而，依赖Caclite进行优化的数据处理系统通常会包含自己的规则以允许特定的重写。

例如，Calcite 为 Apache Cassandra提供了一个适配器，这是一种宽列存储，它按表中的列子集对数据进行分区，然后在每个分区内根据另一个列子集对行进行排序。正如第 5 节中所讨论的，适配器将尽可能多的查询处理下推到每个后端以提高效率是有益的。将排序推入Cassandra 的规则必须检查两个条件

(1)该表之前已被过滤到单个分区（因为行仅在分区内排序）

(2)Cassandra 中的分区排序具有一些与所需排序相同的前缀

这需要将LogicalFilter重写为CassandraFilter以确保分区过滤器被下推到数据库。规则的效果很简单（将LogicalSort转换为CassandraSort） ，但规则匹配的灵活性使后端即使在复杂的场景中也可以下推运算符。

有关具有更复杂效果的规则的示例，请考虑以下查询：

```sql
SELECT products . name , COUNT (*)
FROM sales JOIN products USING ( productId )
WHERE sales . discount IS NOT NULL
GROUP BY products . name
ORDER BY COUNT (*) DESC ;
```

该查询对应于图 4a 中所示的关系代数表达式。因为WHERE子句仅适用于sales表，所以我们可以将过滤器移到连接之前，如图4b 所示。这种优化可以显着减少查询执行时间，因为我们不需要对与谓词匹配的行执行连接。此外，如果销售和产品表包含在单独的后端中，则在连接之前移动过滤器也可能使适配器将过滤器推入后端。Calcite 通过FilterIntoJoinRule实现此优化，它将过滤器节点与连接节点作为父节点进行匹配，并检查连接是否可以执行过滤器。

这种优化说明了Calcite优化方法的灵活性。

**Metadata providers。**元数据是 Calcite 优化器的重要组成部分，它有两个主要目的：

(1)指导规划器实现降低总体查询计划成本的目标

(2）在应用规则时向规则提供信息

Metadata providers负责向优化器提供该信息。特别是， Calcite 中的默认元数据提供程序实现包含返回在运算符树中执行子表达式的总体成本、该表达式结果的行数和数据大小以及最大并行度的函数。它可以被执行。反过来，它还可以提供有关计划结构的信息，例如存在于某个树节点下方的过滤条件。

   Calcite 提供的接口允许数据处理系统将其元数据信息插入到框架中。这些系统可能选择编写覆盖现有函数的提供程序，或者提供自己的新元数据函数，这些函数可能在优化阶段使用。然而，对于他们中的许多人来说，提供有关其输入数据的统计信息就足够了，例如，表的行数和大小、给定列的值是否唯一等，Calcite 将通过以下方式完成其余工作使用其默认实现。

由于元数据提供程序是可插入的，因此它们在运行时使用 Janino（一个 Java 轻量级编译器）进行编译和实例化。它们的实现包括元数据结果的缓存，这可以显着提高性能，例如，当我们需要计算多种类型的元数据（例如基数、平均行大小和给定连接的选择性）时，所有这些计算都依赖于他们的输入的基数。

**Planner engines。**规划引擎的主要目标是触发提供给引擎的规则，直到达到给定的目标。目前，Calcite 提供两种不同的引擎。新引擎可插入框架中。

第一个是基于成本的规划器引擎，它触发输入规则，其目标是降低总体表达成本。该引擎使用类似于 Volcano的动态编程算法来创建和跟踪通过触发给引擎的规则。最初，每个表达式以及基于表达式属性及其输入的摘要一起注册到规划器。当对表达式e1触发规则并且该规则生成新表达式e2时，规划器会将e2添加到e1所属的等价表达式集合Sa中。此外，规划器还会生成新表达式的摘要，并将其与之前在规划器中注册的表达式进行比较。

如果找到与属于集合Sb 的表达式e3关联的相似摘要，则规划器已找到重复项，因此会将Sa和Sb合并为一组新的等价项。该过程持续进行，直到规划器达到可配置的固定点。特别是，它可以（i）详尽地探索搜索空间，直到所有规则都应用于所有表达式

（ii）当计划成本的改善没有超过给定阈值时，使用基于启发式的方法来停止搜索最后一次规划器迭代中的δ 。允许优化器决定选择哪个计划的成本函数是通过元数据提供者提供的。默认成本函数实现结合了对给定表达式使用的 CPU、IO 和内存资源的估计

第二个引擎是详尽的规划器，它详尽地触发规则，直到生成不再被任何规则修改的表达式。该规划器对于快速执行规则非常有用，而无需考虑每个表达式的成本。

用户可以根据自己的具体需求选择使用现有的规划器引擎之一，并且当系统需求发生变化时，从一个引擎切换到另一个引擎也很简单。

或者，用户可以选择生成多阶段优化逻辑，其中在优化过程的连续阶段中应用不同的规则集。重要的是，两个规划器的存在允许 Calcite 用户通过指导搜索不同的查询计划来减少整体优化间。

物化视图。加速数据仓库中查询处理的最强大技术之一是相关摘要或物化视图的预计算。多个 Calcite 适配器和依赖 Calcite 的项目都有自己的物化视图概念。例如，Cassandra 允许用户基于系统自动维护的现有表定义物化视图。

这些引擎将其物化视图暴露给Calcite。然后，优化器有机会重写传入查询以使用这些视图而不是原始表。特别是，Calcite提供了两种不同的基于物化视图的重写算法的实现。

第一种方法基于视图替换[10, 18]。目的是用使用物化视图的等价表达

式替换部分关系代数树，算法进行如下：

（i）物化视图上的扫描算子和物化视图定义计划向规划器注册

（ii）触发尝试统一规划中的表达式的

转换规则。视图不需要与被替换的查询中的表达式完全匹配，因为 Calcite中的重写算法可以产生部分重写，其中包括用于计算所需表达式的附加运算符，例如具有剩余谓词条件的过滤器。

第二种方法基于lattices。一旦数据源被声明形成一个lattices，Calcite代表每个将具体化作为图块，优化器可以使用lattices来回答传入的查询。一方面，重写算法在匹配以星型模式组织的数据源上的表达式时特别有效，这在OLAP 应用程序中很常见。另一方面，它比视图替换更具限制性，因为它对底层模式施加了限制。

## 7. 扩展Calcite

正如我们在前面几节中提到的，Calcite 不仅适合SQL 处理。事实上，Calcite 提供了对 SQL 的扩展，用于表达对其他数据抽象的查询，例如半结构化、流数据和地理空间数据。其内部运算符适应这些查询。除了 SQL 的扩展之外，Calcite 还包括语言集成的查询语言。我们在本节中描述这些扩展并提供一些示例。

## 7.1 Semi-structured Data

Calcite 支持多种复杂的列数据类型，可以将关系数据和半结构化数据混合存储在表中。具体来说，列可以是ARRAY、 MAP或MULTISET类型。

此外，这些复杂类型可以嵌套，因此可以有一个MAP ，其中的值是 ARRAY 类型。可以使用[]运算符提取ARRAY和MAP列中的数据（以及其中的嵌套数据） 。不需要预定义存储在任何这些复杂类型中的值的特定类型。

例如，Calcite 包含 MongoDB [36] 的适配器， MongoDB 是一个文档存储，用于存储由大致相当于 JSON 文档的数据组成的文档。为了将 MongoDB数据公开给 Calcite，需要为每个文档集合创建一个表，其中包含一个名为_MAP 的列：从文档标识符到其数据的映射。在许多情况下，文档应该具有共同的结构。表示邮政编码的文档集合可能每个都包含带有城市名称、纬度和经度

的列。将此数据公开为关系表可能很有用。在方解石中，这是通过在提取所需值

并将其转换为适当的类型后创建视图来实现的：

```sql
SELECT CAST ( _MAP ['city '] AS varchar (20)) AS city ,
CAST ( _MAP ['loc '][0] AS float ) AS longitude ,
CAST ( _MAP ['loc '][1] AS float ) AS latitude
FROM mongo_raw . zips ;
```

通过以这种方式定义的半结构化数据的视图，可以更轻松地与关系数据一起操作来自不同半结构化源的数据。

## 7.2 Streaming

Calcite 为基于流查询提供一流的支持对标准 SQL 的一组特定于流的扩展，即STREAM 扩展、窗口扩展、隐式引用通过连接等中的窗口表达式到流。 这些扩展的灵感来自连续查询语言同时还尝试与标准 SQL 有效集成。 这主扩展，STREAM指令告诉系统用户对传入记录感兴趣，而不是现有记录。

```sql
SELECT STREAM rowtime , productId , units
FROM Orders
WHERE units > 25;
```

在查询流时缺少 STREAM 关键字的情况下，查询变成常规关系查询，表明系统应处理已收到的现有记录来自流，而不是传入的流。由于流固有的无界性质，窗口ing 用于解锁阻塞运算符，例如聚合和加入。 Calcite 的流扩展使用 SQL 分析函数来表达滑动和级联窗口聚合，如图所示 下面的例子。

```sql
SELECT STREAM rowtime ,
productId ,
units ,
SUM( units ) OVER ( ORDER BY rowtime
PARTITION BY productId
RANGE INTERVAL '1' HOUR PRECEDING ) unitsLastHour
FROM Orders ;
```

Tumbling, hopping和会话窗口由TUMBLE启用，HOPPING、SESSION 函数和相关实用函数，例如TUMBLE_END 和 HOP_END 可以分别GROUP BY clauses and projections.

```sql
SELECT STREAM
TUMBLE_END ( rowtime , INTERVAL '1' HOUR ) AS rowtime ,
productId ,
COUNT (*) AS c ,
SUM( units ) AS units
FROM Orders
GROUP BY TUMBLE ( rowtime , INTERVAL '1' HOUR ), productId ;
```

涉及窗口聚合的流式查询要求GROUP BY中存在单调或准单调表达式子句或在滑动和级联情况下的ORDER BY子句中HOPPING、 SESSION函数和相关实用函数，例如窗口查询。

涉及更复杂的流到流的流式查询连接可以使用隐式（时间）窗口表达式来表达在 JOIN 子句中。

```sql
SELECT STREAM o . rowtime , o . productId , o . orderId ,
s . rowtime AS shipTime
FROM Orders AS o
JOIN Shipments AS s
ON o . orderId = s . orderId
AND s . rowtime BETWEEN o . rowtime AND
o . rowtime + INTERVAL '1' HOUR ;
```

在隐式窗口的情况下，Calcite 的查询规划器验证表达式是单调的。

## 7.3 Geospatial Queries

Calcite在地理空间支持方面还处于初步阶段，但正在使用Calcite的关系代数进行实现。该实现的核心是添加一个新的GEOMETRY数据类型，该类型封装了不同的几何对象，如点、曲线和多边形。预计Calcite将完全符合OpenGIS Simple Feature Access规范，该规范定义了用于访问地理空间数据的SQL接口的标准。下面是一个示例查询，找到包含阿姆斯特丹市的国家。

```sql
SELECT name FROM (
SELECT name ,
ST_GeomFromText ('POLYGON ((4.82 52.43 , 4.97 52.43 , 4.97 52.33 ,
4.82 52.33 , 4.82 52.43)) ') AS " Amsterdam ",
ST_GeomFromText ( boundary ) AS " Country "
FROM country
) WHERE ST_Contains (" Country ", " Amsterdam ");
```

## 7.4 Language-Integrated Query for Java

Calcite可以用于查询多个数据源，不仅限于关系数据库。但它的目标不仅仅是支持SQL语言。尽管SQL仍然是主要的数据库语言，但许多程序员更喜欢像LINQ 这样的语言集成语言。与嵌入在Java或C++代码中的SQL不同，语言集成查询语言允许程序员使用单一语言编写所有代码。Calcite提供了针对Java的语言集成查询（简称为LINQ4J），它紧密遵循Microsoft的.NET语言中LINQ所设定的约定。
